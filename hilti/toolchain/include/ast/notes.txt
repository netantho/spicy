
Main changes:

    - Switched to traditional class hierarchy for AST nodes, with
      `Node` at the top.

    - Modeling type constness with a new node `QualifiedType`, instead
      of coding it into all `Type` instances. `Type` has been renamed
      into `UnqualifiedType` for easier distinguishing and so that the
      compiler will catch existing usage of the old `Type` that hasn't
      been updated.

    - IDs are no longer nodes themselves, just node attributes like
      other atomic values.

    - We now instantiate all nodes through static factory methods
      called `create()` that take an additional global `ASTContext`
      instance, which maintains AST-wide state. To facilitate this
      approach, all node constructors are private now; the caller must
      go through the `create()` methods.

    - To make usage of the `create()` methods easier, there's a new
      `NodeFactory` class that provides forwarding methods. The
      factory stores the relevant `ASTContext` internally and
      automatically adds it during forwarding. This factory also
      replaces the old `builder::*` functions for creating AST nodes.
      Over time, we we will port more of the more complex `builder::*`
      functions over into the factory as well, as needed.

      The forwarding methods are automatically generated through
      `scripts/autogen-builder-api` (which, in turn, uses a
      libclang-based tool `bin/autogen-builder-api`).

    - Nodes now keep pointers to their parents. That replaces the
      old `position_t` stuff.

    - No singleton nodes anymore, they don't play well with that
      parent pointering.

    - No `node::None` anymore, using `nullptr` instead. Likewise, no
      `optional<SomeNode>` anymore, using `nullptr` as well.

    - For visitors, we're using traditional double-dispatch with
      virtual methods. No more complex template magic, and no more
      result values from visitors either. There are just two visitor
      variants now for pre-order and post-order walking (and those two
      are still implemented through a joined template).

    - Unresolved types: Use `Auto` if the type is presumably still
      going to be resolved, and `Unknown` if the type has been
      determined to be finally unresolvable.

    - To render AST nodes and reheated objects in a way that's
      user-presentable, use `print()` methods. In contrast, `render()`
      is limited to dump out debug information, in particular the AST
      (TODO: rename `render` to something more debugish?)

    - Resolver/coercer/normalizer have all merged into a new, single
      pass called "resolver". The previous separation was confusing
      and hard to maintain.

    - The passes formerly in `compiler/visitors/*.cc` have moved up a
      level and gained their own header files to declare their entry
      points. No more `global.h` either.

Node/AST semantics:

    - No cycles are allowed inside the AST. That means, a child cannot
      point back to a node that's already elsewhere in the AST. That
      also means, each node does have a unique parent. (TODO: Add
      cycle detector so that we catch if we mess it up.)

    - If we semantically need a cycle, there are two approaches:
        1. Create a separate AST node representing the indirection
           (e.g., expression::Name, type::Name)

        2. Do not store the Node pointer as children but as a weak_ptr
           member (i.e., outside of the AST) and manage that manually.

        Both can be combined. For example, expression::Name and
        type::Name maintain a weak_ref to the declaration they are
        referring to, which is set by the resolver.

        Special-case: `QualifiedType` has the built-in capability to
        store a weak pointer to its `UnqualifiedType`, to easily avoid
        typing loops. It's accessed through
        `QualifiedType::createExteranl()`.

    - When adding a node to an AST (i.e., as the child of another
      Node), there are two cases:

        1. It's a new node instance that does not have a parent yet.
           In that case, we directly add a pointer to that Node as the
           child.

        2. It's a node instance that already has a different parent.
           In that case, we deep-copy the node first and add a pointer
           to the copy as the child.

       Note that when wanting to *move* a node from one location
       inside the AST to another, you can avoid the deep-copy by first
       removing it from its old parent (which will clear the parent
       pointer) and then adding it to the new parent.

       Conceptually, there are two main places where this logic
       happens: 1. when manipulating the child of a Node through the
       corresponding Node methods; and 2. when instantiating new Node
       and given them their initial children. Generally, this all happens
       automatically when going through the corresponding methods,
       which deep-copy on-demand as needed.

    - Non-abstract classes derived from Node
        - Public `create()` factory
        - Protected constructors, called from `create()`
        - Protected copy/move constructors/assignment that perform shallow copies.

    - We do type comparison by computing a serialized version of each
      type, then comparing those as strings. An empty serialization
      always compares false against anything else---which can be used
      for types that should never match another one.

    - When comparing types, we distinguish between types that are
      compared structurally (most) and by name ("name types"; e.g.,
      struct and enums).
